#!/mod/bin/jimsh
#
# Experimental.
# Render the details of the .ts video files under the My Video directory.
# Called over CGI to update a page, or as a CLI for hosting on a different server.
# After successfully rendering the data, the value "status" is set to "OK".
# If there is an error, "status" is set to "<error message>".
# Clients should therefore check "status" first. If there is a serious server error part way
# through rendering, the JSON may be malformed and not parsable.
#
# CGI usage: /tvdiary/inventory_json.jim
# CLI usage: inventory_json.jim
#
# Author: Martin Wink, 2014.
#

package require cgi
source /mod/webif/lib/setup
source /mod/webif/html/tvdiary/tvdiary_db.jim

if { ![exists -proc sqlite3.open] } { package require sqlite3 }

# --------------------------------------------------------------
# Declare globals
# --------------------------------------------------------------
set current_time [clock seconds]
set time_fmt "%H:%M"
set date_time_fmt "%a %d %b %Y $time_fmt"

set DB_FILEPATH "/mod/etc/tvdiary.db"

set channel_icons_path "/mod/webif/html/img/channels/out"
set channel_icons_url "/img/channels/out"

# --------------------------------------------------------------
# CGI or command line parameters
# --------------------------------------------------------------
set runmode cli
if { [dict exists $env "REQUEST_METHOD"] } { set runmode cgi }

case $runmode {
  cgi {
    cgi_input
    httpheader "application/json"
  }
  cli {
  }
}

# In case of error - break glass!
#puts "/* "
#foreach key [lsort [dict keys $env]] {puts "env($key)=$env($key)"}
#puts "auto_path=$auto_path"
#puts "*/"

# --------------------------------------------------------------
# Declare procedures
# --------------------------------------------------------------

#
# Initialize a map from control characters to JSON escaped characters. 
# Initially all non-null control characters to \u00xx sequences.
for {set i 1} {$i < 32} {incr i} {
  set json_escape_map([format %c $i]) \\u[format %04x $i]
}
# Then overwrite certain well known control characters with shorter versions.
set json_escape_map([format %c 8]) \\b; # backspace
set json_escape_map([format %c 9]) \\t; # tab
set json_escape_map([format %c 10]) \\n; # lf
set json_escape_map([format %c 12]) \\f; # ff
set json_escape_map([format %c 13]) \\r; # cr
# Other special sequences
set json_escape_map(\") {\"}
set json_escape_map(\\) {\\}
set json_escape_map(/)  {\/}

#
# Escape a string for inclusion in JSON output.
#
proc escape_json_string { in } {
  return [string map $::json_escape_map $in]
}

#
# Common output of a table row.
#
proc output_record { record } {
  puts " {"
  puts "  \"inventory_id\": $record(inventory_id),"
  puts "  \"directory\": \"$record(directory)\","
  puts "  \"filename\": \"$record(filename)\","
  puts "  \"size\": $record(size),"
  
  set channel_name $record(channel_name)
  puts "  \"channel_name\": \"[escape_json_string $channel_name]\","
  set channel_icon_path "$::channel_icons_url/Unknown.png"
  if { $channel_name != "" } {
    if { [file exists "$::channel_icons_path/$channel_name.png"] } {
      set channel_icon_path "$::channel_icons_url/[cgi_quote_url $channel_name].png"
    } else {
      set channel_icon_path "$::channel_icons_url/Unknown.png"
    }
  }
  puts "  \"channel_icon_path\": \"$channel_icon_path\","

  set filepath "$record(directory)/$record(filename)"
  set thumbnail [file exists "[file rootname $filepath].thm"]
  puts "  \"has_thumbnail\": [expr { $thumbnail ? {true} : {false} }],"
  
  set repeat_id $record(repeat_id)
  if { $repeat_id == {} } {
    set repeat_id -1
  }
  puts "  \"repeat_id\": $repeat_id,"

  if { $record(watched) } {
    set watched "true"
  } else {
    set watched "false"
  }
  puts "  \"watched\": $watched,"

  set event_duration [expr ($record(event_end) - $record(event_start) + 30) / 60]
  puts "  \"title\": \"[escape_json_string $record(title)]\","
  puts "  \"synopsis\": \"[escape_json_string $record(synopsis)]\","
  puts "  \"event_start\": $record(event_start),"
  puts "  \"event_duration\": $event_duration,"
  puts "  \"scheduled_start\": $record(scheduled_start),"
  puts "  \"scheduled_duration\": $record(scheduled_duration)"
  puts -nonewline " }"
}

#
# Main
#
proc main {} {
  # begin_debug
  #  puts "/* Parameters:
  #  time_start=$::time_start=[clock format $::time_start]
  #  time_end=$::time_end=[clock format $::time_end]
  #  type=$::type */"
  # end_debug

  #
  # Check we have a database, and open it, else HTTP error.
  #
  if { ![file exists $::DB_FILEPATH] } {
    # Ajax detects the error if we just exit.
    throw error "The tvdiary.db database is missing."
  }

  #
  # Get a lock for the database
  #
  if {![acquire_lock tvdiary_db]} {
    throw error "Timed out acquiring exclusive access to the database. Try again later."
  }

  set tvdiarydb [sqlite3.open $::DB_FILEPATH]

  #
  # Update the cached inventory.
  #
  update_inventory $tvdiarydb [system mediaroot] [system dustbin]

  #
  # Query the inventory for generating JSON.
  #
  set records [$tvdiarydb query "
    SELECT inventory.*,
    (SELECT COUNT(*) FROM activities, programs
      WHERE programs.start = inventory.scheduled_start AND programs.channel_name = inventory.channel_name
        AND activities.program_id = programs.program_id AND (activities.type = 'P' OR activities.type = 'L') AND activities.end != 0) AS watched,
    (SELECT program_id FROM programs WHERE programs.title = inventory.title AND programs.synopsis = inventory.synopsis AND programs.start != inventory.scheduled_start) AS repeat_id
    FROM inventory
    ORDER BY directory, event_start DESC, title"]
  
  # Finished with the DB.
  $tvdiarydb close

  #
  # Closed the DB so release the lock.
  #
  release_lock tvdiary_db
  
  puts "{"
  puts -nonewline " \"events\": \["
  set comma 0
  foreach record $records {
    if { $comma } {
      puts ","
    } else {
      puts ""
      set comma 1
    }
    output_record $record
  }
  puts ""
  puts " \],"

  puts " \"status\": \"OK\""
  puts "}"
}

if { $runmode == "cgi" } {
  try {
    main
  } on error { msg } {
    puts "{ \"status\": \"[escape_json_string $msg]\" }"
  }
} else {
  main
}
