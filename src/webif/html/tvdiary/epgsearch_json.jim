#!/mod/bin/jimsh
#
# Render the details of all program activities sharing either the title and synopsis,
# or just the title, of the one identified by the program or title ID.
# If the program ID is supplied then the title and synopsis text is matched.
# If the title ID is supplied then just the title is matched.
# All of their record and playback activities are listed.
# After successfully rendering the data, the value "status" is set to "OK".
# If there is an error, "status" is set to the "<error message>".
# Clients should therefore check "status" first. If there is a serious server error part way
# through rendering, the JSON may be malformed and not parsable.
#
# CGI usage: /tvdiary/epgsearch_json.jim?title_op=[E|C|S|F]&title=<title>&synopsis_op=[E|C|S|F]&synopsis=<synopsis>&channel_op=[E|C|S|F]&channel=<channel>
#   title_op = the title operator [E|C|S|F].
#   title = the title text.
#   synopsis_op = the synopsis operator [E|C|S|F].
#   synopsis = the synopsis text.
#   channel_op = the channel operator [E|C|S|F].
#   channel = the channel text.
#
# Author: Martin Wink, 2014.
#

package require cgi
source /mod/webif/lib/setup
source /mod/webif/html/tvdiary/tvdiary_db.jim
require mwildcard

if { ![exists -proc sqlite3.open] } { package require sqlite3 }

# --------------------------------------------------------------
# Declare globals
# --------------------------------------------------------------
set current_time [clock seconds]
set time_fmt "%H:%M"
set date_time_fmt "%a %d %b %Y $time_fmt"

set channel_icons_path "/mod/webif/html/img/channels/out"
set channel_icons_url "/img/channels/out"

set program_id_specified 0
set title_id_specified 0
set channel_id_specified 0

# --------------------------------------------------------------
# CGI parameters
# --------------------------------------------------------------
set runmode cli
if { [dict exists $env "REQUEST_METHOD"] } { set runmode cgi }

case $runmode {
  cgi {
    cgi_input
    set title [cgi_get title]
    set synopsis [cgi_get synopsis]
    set channel [cgi_get channel]

    set title_op [cgi_get title_op]
    set synopsis_op [cgi_get synopsis_op]
    set channel_op [cgi_get channel_op]
    httpheader "application/json"
  }
  cli {
    set title ""
    set synopsis ""
    set channel ""
    set title_op ""
    set synopsis_op ""
    set channel_op ""
    if { $argc == 8 } {
      set title_op [lindex $argv 0]
      set title [lindex $argv 1]
      set synopsis_op [lindex $argv 2]
      set synopsis [lindex $argv 3]
      set channel_op [lindex $argv 4]
      set channel [lindex $argv 5]
      set channel_icons_path [lindex $argv 6]
      set channel_icons_url [lindex $argv 7]
    } else {
      puts "Usage: $argv0 <title_op> <title> <synopsis_op> <synopsis> <channel_op> <channel> <icons_path> <icons_url>"
      puts "  title_op = the title operator \[E|C|S|F\]."
      puts "  title = the title text."
      puts "  synopsis_op = the synopsis operator \[E|C|S|F\]."
      puts "  synopsis = the synopsis text."
      puts "  channel_op = the channel operator \[E|C|S|F\]."
      puts "  channel = the channel text."
      puts "  icons_path = disk path to the TV channel icons"
      puts "  icons_url = URL path to the TV channel icons"
      puts ""
      puts "Eg: $argv0 E \"\" C \"cycle\" E \"\" $channel_icons_path $channel_icons_url"
      exit -1
    }
  }
}

# In case of error - break glass!
#puts "/* "
#foreach key [lsort [dict keys $env]] {puts "env($key)=$env($key)"}
#puts "auto_path=$auto_path"
#puts "*/"

# --------------------------------------------------------------
# Declare procedures
# --------------------------------------------------------------

#
# Convert from op code to operator text.
#
proc op_code_to_operator { op } {
  if { $op eq "E" } {
    return "="
  } else {
    return "LIKE"
  }
}

#
# Convert from op code to parameter text.
#
proc op_code_to_parameter { op val } {
  if { $op eq "C" } {
    return "%[mwildcard $val]%"
  } elseif { $op eq "S" } {
    return "[mwildcard $val]%"
  } elseif { $op eq "F" } {
    return "%[mwildcard $val]"
  } else {
    return "[mwildcard $val]"
  }
}

#
# Main
#
proc main {} {
  # begin_debug
  #puts "/* Parameters:
  #  title=$::title
  #  synopsis=$::synopsis
  #  channel=$::channel */"
  #  title_op=$::title_op
  #  synopsis_op=$::synopsis_op
  #  channel_op=$::channel_op */"
  # end_debug

  #
  # Check we have a database, and open it, else HTTP error.
  #
  if { ![file exists $::DB_FILEPATH] } {
    throw error "The $::DB_FILEPATH database is missing."
  }
  if { ![file exists $::EPG_DB_PATH] } {
    throw error "The $::EPG_DB_PATH database is missing."
  }
  if { ![file exists $::CHANNEL_DB_PATH] } {
    throw error "The $::CHANNEL_DB_PATH database is missing."
  }
  if { ![file exists $::RSV_DB_PATH] } {
    throw error "The $::RSV_DB_PATH database is missing."
  }

  #
  # Get a lock for the database
  #
  if {![acquire_lock tvdiary_db]} {
    throw error "Timed out acquiring exclusive access to the database. Try again later."
  }

  set tvdiarydb [sqlite3.open $::DB_FILEPATH]
  $tvdiarydb query {attach database '%s' as channel} $::CHANNEL_DB_PATH
  $tvdiarydb query {attach database '%s' as epg} $::EPG_DB_PATH
  $tvdiarydb query {attach database '%s' as rsv} $::RSV_DB_PATH
  
  # Build list of events to check whether search results are scheduled for recording.
  set future_events [build_future_events_list $tvdiarydb 0 [clock seconds]]

  set title_operator [op_code_to_operator $::title_op]
  set synopsis_operator [op_code_to_operator $::synopsis_op]
  set channel_operator [op_code_to_operator $::channel_op]

  set records [$tvdiarydb query "
    SELECT SUBSTR(c.szSvcName, 2) AS channel_name, e.name AS title, e.text AS synopsis, e.start, e.end, e.duration, e.warning, e.content_type, e.content, e.event_crid, e.series_crid, e.rec_crid,
      (SELECT COUNT(*) FROM programs WHERE programs.crid = e.event_crid) as repeat_crids,
      (SELECT program_id
        FROM programs, titles, synopses
        WHERE programs.title_id = titles.title_id
          AND programs.synopsis_id = synopses.synopsis_id
          AND titles.title = e.name
          AND synopses.synopsis = e.text
          AND EXISTS (SELECT activity_id FROM activities WHERE activities.program_id = programs.program_id AND (activities.type = 'P' OR activities.type = 'L') AND activities.end != 0 ) LIMIT 1) AS repeat_id
    FROM epg.epg e, channel.TBL_SVC c
    WHERE e.end >= %s
      AND e.service_id = c.usSvcId
      AND ('%s' = '' OR e.name $title_operator '%s')
      AND ('%s' = '' OR c.szSvcName $channel_operator '%s')
      AND ('%s' = '' OR e.text $synopsis_operator '%s')
    ORDER BY e.start" [clock seconds] $::title [op_code_to_parameter $::title_op $::title] $::channel [op_code_to_parameter $::channel_op $::channel] $::synopsis [op_code_to_parameter $::synopsis_op $::synopsis]]

  # Finished with the DBs.
  $tvdiarydb close

  #
  # Closed the DB so release the lock.
  #
  release_lock tvdiary_db

  puts "{"
  puts " \"title_op\": \"[escape_json_string $::title_op]\","
  puts " \"title\": \"[escape_json_string $::title]\","
  puts " \"synopsis_op\": \"[escape_json_string $::synopsis_op]\","
  puts " \"synopsis\": \"[escape_json_string $::synopsis]\","
  puts " \"channel_name_op\": \"[escape_json_string $::channel_op]\","
  puts " \"channel_name\": \"[escape_json_string $::channel]\","
  puts -nonewline " \"events\": \["

  if { [llength $records] > 0 } {
    set comma 0
    foreach record $records {
      if { $comma } {
        puts ","
      } else {
        puts ""
        set comma 1
      }

      puts "{"
      puts " \"title\": \"[escape_json_string $record(title)]\","
      puts " \"synopsis\": \"[escape_json_string $record(synopsis)]\","
      puts " \"channel_name\": \"[escape_json_string $record(channel_name)]\","

      set channel_icon_path "$::channel_icons_url/Unknown.png"
      if { $record(channel_name) != "" } {
        if { [file exists "$::channel_icons_path/$record(channel_name).png"] } {
          set channel_icon_path "$::channel_icons_url/[cgi_quote_url $record(channel_name)].png"
        } else {
          set channel_icon_path "$::channel_icons_url/Unknown.png"
        }
      }
      puts " \"channel_icon_path\": \"$channel_icon_path\","

      puts " \"start\": $record(start),"
      puts " \"end\": $record(end),"
      puts " \"duration\": $record(duration),"
      puts " \"warning\": \"$record(warning)\","
      puts " \"content_type\": $record(content_type),"
      puts " \"content\": \"$record(content)\","
      puts " \"event_crid\": \"$record(event_crid)\","
      puts " \"series_crid\": \"$record(series_crid)\","
      puts " \"rec_crid\": \"$record(rec_crid)\","

      # Count of CRIDs. If > 0 use the event_crid
      if { $record(repeat_crids) > 0 } {
        puts " \"repeat_crid\": \"$record(event_crid)\","
      } else {
        puts " \"repeat_crid\": \"\","
      }

      # The first matching program_id
      set repeat_id $record(repeat_id)
      if { $repeat_id == {} } {
        set repeat_id -1
      }
      puts " \"repeat_id\": $repeat_id,"

      # Check if the event is in the schedule
      set key "$record(start):$record(channel_name)"
      if { [dict exists $future_events $key] } {
        set vals [dict get $future_events $key]
        if { $vals(ucRecKind) == 1 } {
          puts " \"to_be_recorded\": 1"
        } else {
          puts " \"to_be_recorded\": 2"
        }
      } else {
        puts " \"to_be_recorded\": 0"
      }
      
      puts -nonewline "}"
    }
  }
  puts ""
  puts " \],"

  puts " \"status\": \"OK\""
  puts "}"
}

##########

#
# Split the aul binary data into a list of {service_id start end event_id} lists.
#
proc aul { aulEventToRecordInfo } {
  if {![exists -proc binary]} { package require binary }
  set aul {}
  for {set i 0} {$i < [string length $aulEventToRecordInfo]} {incr i 16} {
    binary scan [string range $aulEventToRecordInfo $i $($i + 15)] \
        iiii service start end event_id
    catch {lappend aul [list $service $start $end $event_id]}
  }
  return $aul
}

#
# Build a list of dictionary rows for future events.
# The DB must have epg, rsv & channels attached.
#
proc build_future_events_list { tvdiarydb chk_repeats { min_time 0 } { max_time 9999999999 } } {
  set future_events {}

  # Optional checking for repeats - both matching title & synopsis and by CRID.
  if { $chk_repeats } {
    set repeats_clause {
      ,
      (SELECT COUNT(*) FROM tvdiary.programs WHERE tvdiary.programs.crid = e.event_crid) as repeat_crids,
      (SELECT program_id
        FROM tvdiary.programs, tvdiary.titles, tvdiary.synopses
        WHERE tvdiary.programs.title_id = tvdiary.titles.title_id
          AND tvdiary.programs.synopsis_id = tvdiary.synopses.synopsis_id
          AND tvdiary.titles.title = e.name
          AND tvdiary.synopses.synopsis = e.text
          AND EXISTS (SELECT activity_id FROM tvdiary.activities WHERE tvdiary.activities.program_id = tvdiary.programs.program_id AND (tvdiary.activities.type = 'P' OR tvdiary.activities.type = 'L') AND tvdiary.activities.end != 0 ) LIMIT 1) AS repeat_id
    }
    set aul_repeats_clause {
      ,
      (SELECT COUNT(*) FROM tvdiary.programs WHERE tvdiary.programs.crid = e.event_crid) as repeat_crids,
      (SELECT program_id
        FROM tvdiary.programs, tvdiary.titles, tvdiary.synopses
        WHERE tvdiary.programs.title_id = tvdiary.titles.title_id
          AND tvdiary.programs.synopsis_id = tvdiary.synopses.synopsis_id
          AND tvdiary.titles.title = e.name
          AND tvdiary.synopses.synopsis = e.text
          AND EXISTS (SELECT activity_id FROM tvdiary.activities WHERE tvdiary.activities.program_id = tvdiary.programs.program_id AND (tvdiary.activities.type = 'P' OR tvdiary.activities.type = 'L') AND tvdiary.activities.end != 0 ) LIMIT 1) AS repeat_id
    }
  } else {
    set repeats_clause {}
    set aul_repeats_clause {}
  }

  # Get the details of the scheduled events.
  # Always get the rsv and channel.
  # Outer join epg in case it's in a state of flux and not found.
  # Filter r.ersvtype: 3 == recording vs. a reminder, wake-up, sleep or auto-update event.
  # Filter r.ucRecKind: 1 == one-off, 2 == split, 4 == series.
  set records [$tvdiarydb query "
    SELECT r.nsttime, r.nduration, r.aulEventToRecordInfo, r.ersvtype, r.ucRecKind, r.hsvc,
      SUBSTR(c.szSvcName, 2) AS channel_name,
      e.name AS title, e.text AS synopsis, e.start, e.end, e.duration, e.event_crid, e.service_id
      $repeats_clause
    FROM rsv.TBL_RESERVATION r, channel.TBL_SVC c
    LEFT OUTER JOIN epg e
      ON e.service_id = c.usSvcId
      AND e.start = r.nsttime
    WHERE (r.nsttime + r.nduration) >= %s AND r.nsttime < %s 
      AND r.ersvtype = 3 AND (r.ucRecKind = 1 OR r.ucRecKind = 2 OR r.ucRecKind = 4)
      AND r.hsvc = c.hSvc
    ORDER BY r.nsttime, c.szSvcName" $min_time $max_time]

  foreach record $records {
    # Use values from the rsv rather than epg where possible.
    set vals [dict create "channel_name" $record(channel_name) "scheduled_start" $record(nsttime) "scheduled_end" [expr $record(nsttime) + $record(nduration)] "scheduled_duration" $record(nduration) "ucRecKind" $record(ucRecKind)]
    # Check epg.start to see if it's found in the EPG.
    if { $record(start) == {} } {
      dict set vals "title" "Not in EPG"
      dict set vals "synopsis" "No information available"
      dict set vals "repeat_id" {}
      dict set vals "repeat_crid" {}
    } else {
      dict set vals "title" $record(title)
      dict set vals "synopsis" $record(synopsis)
      if { $chk_repeats } {
        dict set vals "repeat_id" $record(repeat_id)
        if { $record(repeat_crids) > 0 } {
          dict set vals "repeat_crid" $record(repeat_crids)
        } else {
          dict set vals "repeat_crid" {}
        }
      } else {
        dict set vals "repeat_id" {}
        dict set vals "repeat_crid" {}
      }
      # Some assertions:
      if { $record(nsttime) != $record(start) } {
        throw error "***** RSV and EPG start discrepency. $record(nsttime) != $record(start)"
      }
      if { $record(nduration) != $record(duration) } {
        throw error "***** RSV and EPG duration discrepency. $record(nduration) != $record(duration)"
      }
      if { [expr $record(nsttime) + $record(nduration)] != $record(end) } {
        throw error "***** RSV and EPG end discrepency. [expr $record(nsttime) + $record(nduration)] != $record(end)"
      }
    }
    set key "$record(nsttime):$record(channel_name)"
    dict set future_events $key $vals

    # Check for subsequent events.
    set elist [aul $record(aulEventToRecordInfo)]
    foreach e $elist {
      lassign $e hservice start end event_id
      if { $hservice == $record(hsvc) && $start == $record(nsttime) } {
        # Usually the first entry matches the containing row. Skip.
      } elseif { $end < $min_time || $start > $max_time } {
        # If the subsequent events are out of range, skip.
      } else {
        # Otherwise search for details.
        # Again, outer join EPG so values may be null.
        set aulrecords [$tvdiarydb query "
          SELECT SUBSTR(c.szSvcName, 2) AS channel_name,
            e.name AS title, e.text AS synopsis, e.start, e.end, e.duration, e.event_crid
            $aul_repeats_clause
          FROM channel.TBL_SVC c
          LEFT OUTER JOIN epg e
           ON e.service_id = c.usSvcId
           AND e.start = %s
          WHERE c.hSvc = %s
          ORDER BY e.start, c.szSvcName" $start $hservice]
        if { [llength $aulrecords] != 1 } {
          throw error "***** Record count != 1 for an aul entry."
        }
        foreach aulrecord $aulrecords {
          # Use values from the aul rather than epg where possible. ucRecKind from the main record.
          set vals [dict create "channel_name" $aulrecord(channel_name) "scheduled_start" $start "scheduled_end" $end "scheduled_duration" [expr $end - $start] "ucRecKind" $record(ucRecKind)]
          # Check epg.start to see if it's found in the EPG.
          if { $aulrecord(start) == {} } {
            dict set vals "title" "Not in EPG"
            dict set vals "synopsis" "No information available"
            dict set vals "repeat_id" {}
            dict set vals "repeat_crid" {}
          } else {
            dict set vals "title" $aulrecord(title)
            dict set vals "synopsis" $aulrecord(synopsis)
            if { $chk_repeats } {
              dict set vals "repeat_id" $aulrecord(repeat_id)
              if { $aulrecord(repeat_crids) > 0 } {
                dict set vals "repeat_crid" $aulrecord(event_crid)
              } else {
                dict set vals "repeat_crid" {}
              }
            } else {
              dict set vals "repeat_id" {}
              dict set vals "repeat_crid" {}
            }
            # Some assertions:
            if { $start != $aulrecord(start) } {
              throw error "***** AUL and EPG start discrepency. $start != $aulrecord(start)"
            }
            if { $end != $aulrecord(end) } {
              throw error "***** AUL and EPG end discrepency. $end != $aulrecord(end)"
            }
            set key "$start:$aulrecord(channel_name)"
            dict set future_events $key $vals
          }
        }
      }

    }
  }
  return $future_events
}


##########

if { $runmode == "cgi" } {
  try {
    main
  } on error { msg } {
    puts "{ \"status\": \"[escape_json_string $msg]\" }"
  }
} else {
  main
}
