#!/mod/bin/jimsh

source /mod/webif/lib/setup
require ts.class

if { ![exists -proc sqlite3.open] } { package require sqlite3 }

######
# Locking based in webif/lib/lock with retry loop added.
######
if { [dict exists $env "REQUEST_METHOD"] } {
  set log_locking 0
} else {
  set log_locking 0
}

proc _lock_to_port {id} {
  set len [string length $id]
  set hash $len

  for {set i 0} {$i < $len} {incr i} {
    scan [string index $id $i] "%c" asc
    set hash [expr (($hash<<5)^($hash>>27))^$asc];
  }

  return [expr (65535 - ($hash % 101))]
}

proc _lock_dummy {newsock addr port} { }

proc acquire_lock {id} {
  global _locks

  set port [_lock_to_port $id]

  # Max 15 seconds timeout.
  set timeout 15

  # 'socket already in use' error will be our lock detection mechanism
  incr timeout [clock seconds]
  if {$::log_locking} { puts "acquire_lock{$id} port:$port now:[clock seconds] timeout:$timeout" }
  while {[catch {set socket [socket stream.server "127.0.0.1:$port"]} msg]} {
    if { [clock seconds] > $timeout } {
      if {$::log_locking} { puts "Could not aquire lock" }
      return 0
    }
    if {$::log_locking} { puts "acquire_lock{$id} starting retry sleep at [clock seconds]" }
    sleep 0.2
  }

  set _locks($id) $socket
  if {$::log_locking} { puts "acquire_lock{$id} succeeded at [clock seconds]" }
  return 1
}

proc release_lock {id} {
  global _locks

  if {$::log_locking} { puts "release_lock{$id} at [clock seconds]" }
  if {[catch {close $_locks($id)} msg]} {
    if {$::log_locking} { puts "Error releasing lock: $msg" }
    return 0
  }
  unset _locks($id)
  return 1
}

######
# Experimental inventory code.
######

#
# Get details and add to the cache.
#
proc add_to_cache { tvdiarydb directory filename } {
  try {
    set filepath "$directory/$filename"
    set ts [ts fetch $filepath]
    set channel_name [$ts get channel_name]
    set title [$ts get title]
    set synopsis [$ts get synopsis]
    set event_start [$ts get start]
    set event_end [$ts get end]
    set schedstart [$ts get schedstart]
    set scheddur [expr [$ts get scheddur] / 60]
    # Use [file] for consistency with checking.
    set size [file size $filepath]

    set channel_id [get_channel_id $tvdiarydb $channel_name]
    set title_id [get_title_id $tvdiarydb $title]
    set synopsis_id [get_synopsis_id $tvdiarydb $synopsis]

    $tvdiarydb query "
      INSERT INTO inventory (flag, directory, filename, size, channel_id, title_id, synopsis_id, event_start, event_end, scheduled_start, scheduled_duration)
      VALUES (%s, '%s', '%s', '%s', %s, %s, %s, %s, %s, %s, %s);" 1 $directory $filename $size $channel_id $title_id $synopsis_id $event_start $event_end $schedstart $scheddur
    set act_id [$tvdiarydb lastid]
#    puts "//[clock seconds]: Added to inventory: $act_id, 1, $directory, $filename, $size, $channel_id, $title_id, $synopsis_id, $schedstart, $scheddur."
  } on error { msg } {
    puts "//[clock seconds]: Error accessing information for $directory/$filename - $msg."
  }
}

#
# Check whether there's an entry for this file.
# Returns the inventory_id.
#
proc check_entry { tvdiarydb directory filename size } {
  set _count [$tvdiarydb query "SELECT inventory_id FROM inventory WHERE directory = '%s' AND filename = '%s' AND size = '%s' LIMIT 1" $directory $filename $size]
  if { [llength $_count] > 0 } {
    return [lindex [lindex $_count 0] 1]
  }
#  puts "Found no match for $directory $filename $size"
  return -1
}

#
# Update the cache recursively, starting at this directory.
#
proc update_inventory_dir { tvdiarydb directory dustbin } {
#  puts "//[clock seconds]: update_inventory_dir $tvdiarydb $directory $dustbin"
  set files [glob -nocomplain -directory $directory *]
  foreach filename $files {
    set filepath "$directory/$filename"
#    puts "//[clock seconds]: Checking file $filepath with extension \"[file extension $filepath]\""
    if { [file isfile $filepath] && [file extension $filepath] eq ".ts" } {
      set id [check_entry $tvdiarydb $directory $filename [file size $filepath]]
      if { $id != -1} {
        $tvdiarydb query "UPDATE inventory SET flag = 1 WHERE inventory_id = %s" $id
#        puts "//[clock seconds]: Set inventory flag for: $id"
      } else {
        add_to_cache $tvdiarydb $directory $filename
      }
    } elseif { [file isdirectory $filepath] } {
        if {$filepath ne $dustbin} {
          update_inventory_dir $tvdiarydb $filepath $dustbin
        }
    } else {
      #puts "//[clock seconds]: Ignoring file $filepath"
    }
  }
}

proc get_setting { tvdiarydb name } {
  set res [$tvdiarydb query "SELECT value FROM settings WHERE name = '$name'"]
  if {$res ne ""} {
    return [lindex [lindex $res end] end]
  }
  return ""
}

proc set_setting { tvdiarydb name value } {
  $tvdiarydb query "REPLACE INTO settings (name, value) VALUES ('$name', '%s')" $value
}

#
# Test whether the named table exists.
# Returns 1 if it exists, else 0.
#
proc table_exists { tvdiarydb name } {
  set res [$tvdiarydb query "SELECT COUNT(*) FROM sqlite_master WHERE type = 'table' AND name = '$name'"]
  if {$res ne ""} {
    return [lindex [lindex $res end] end]
  }
  return 0
}

#
# Get the ID of an existing channel_name, or create a new ID.
#
proc get_channel_id { tvdiarydb name } {
  set res [$tvdiarydb query "SELECT channel_id FROM channels WHERE channel_name = '%s'" $name]
  if {$res ne ""} {
    return [lindex [lindex $res end] end]
  }
  $tvdiarydb query "INSERT INTO channels (channel_name) VALUES ('%s')" $name
  return [$tvdiarydb lastid]
}

#
# Get the ID of an existing title, or create a new ID.
#
proc get_title_id { tvdiarydb title } {
  set res [$tvdiarydb query "SELECT title_id FROM titles WHERE title = '%s'" $title]
  if {$res ne ""} {
    return [lindex [lindex $res end] end]
  }
  $tvdiarydb query "INSERT INTO titles (title) VALUES ('%s')" $title
  return [$tvdiarydb lastid]
}

#
# Get the ID of an existing synopsis, or create a new ID.
#
proc get_synopsis_id { tvdiarydb synopsis } {
  set res [$tvdiarydb query "SELECT synopsis_id FROM synopses WHERE synopsis = '%s'" $synopsis]
  if {$res ne ""} {
    return [lindex [lindex $res end] end]
  }
  $tvdiarydb query "INSERT INTO synopses (synopsis) VALUES ('%s')" $synopsis
  return [$tvdiarydb lastid]
}

#
# Update the cache.
#
proc update_inventory { tvdiarydb directory dustbin} {
#  puts "//[clock seconds]: update_inventory started."

  # Check for recent update
  set last_update [get_setting $tvdiarydb "inventory_update"]
#  if {$last_update eq "" } {set last_update 0}
#  puts "//[clock seconds]: last_update=$last_update and (\[clock seconds\] - \$last_update)=[expr [clock seconds] - $last_update]."
  if {$last_update eq "" || ([clock seconds] - $last_update) > 60} {
    # Clear the flags before scanning the disk.
    $tvdiarydb query "UPDATE inventory SET flag = 0;"
    set changes [$tvdiarydb changes]
#    puts "//[clock seconds]: Cleared $changes inventory flags."
  
    # Recursive directory search, setting the flag if present, or adding rows if not present.
    update_inventory_dir $tvdiarydb $directory $dustbin

    # Purge obsolete cache entries.
    $tvdiarydb query "DELETE FROM inventory WHERE flag = 0;"
    set changes [$tvdiarydb changes]
#    puts "//[clock seconds]: Deleted $changes obsolete inventory entries."
    set_setting $tvdiarydb "inventory_update" [clock seconds]
  }
#  puts "//[clock seconds]: update_inventory finished."
}
