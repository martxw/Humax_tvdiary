#!/mod/bin/jimsh
#
# Aggregate statistics in the tvdiary database.
# Author: Martin Wink, 2014.
#

# In case of error - break glass!
#foreach key [lsort [dict keys $env]] {puts "env($key)=$env($key)"}
#puts "auto_path=$auto_path"

#source /mod/webif/lib/setup
source /mod/webif/html/tvdiary/tvdiary_db.jim
if { ![exists -proc sqlite3.open] } { package require sqlite3 }

# --------------------------------------------------------------
# Declare globals
# --------------------------------------------------------------
set logging 1

set DB_FILEPATH "/mod/etc/tvdiary.db"

set current_time [clock seconds]
set log_date_fmt "%d/%m/%Y-%H:%M:%S"
set logging_time [clock format $current_time -format $log_date_fmt]
if { $::logging } {
  puts "\n$logging_time: tvdiary_aggregate.jim"
}

# --------------------------------------------------------------
# Declare procedures
# --------------------------------------------------------------

#
# Create or open the database file.
#
proc openDB {} {
  set tvdiarydb [sqlite3.open $::DB_FILEPATH]

  return $tvdiarydb;
}

#
# Main
#
proc main {} {
  try {
    #
    # Get a lock for the database.
    #
    if {![acquire_lock tvdiary_db]} {
      throw "Cannot acquire exclusive lock for tvdiary.tb."
    }

    set tvdiarydb [openDB]

    set settings_val [get_setting $tvdiarydb "day_start"]
    if { $settings_val eq "" } {
      set ::day_start 0
    } else {
      set parts [split $settings_val ":"]
      set ::day_start [expr ([lindex $parts 0] * 60 + [lindex $parts 1]) * 60]
    }
    puts "day_start set to $::day_start"

    aggregate $tvdiarydb

    $tvdiarydb close

    #
    # Closed the DB so release the lock.
    #
    release_lock tvdiary_db

    puts "$::logging_time: Aggregation completed successfully."
  } on error { msg } {
    puts "$::logging_time: Aggregation failed. \[$msg\]"
    puts [info stacktrace]
    exit
  }
}

#
# Calculate the aggregated summary statistics.
#
proc aggregate { tvdiarydb } {

  # TODO: Move table creation to migration code. Only here for development.
  # Program fact table. The year and month are dimensions, as are the title and channel IDs.
  $tvdiarydb query "DROP TABLE IF EXISTS program_facts;"
  $tvdiarydb query "CREATE TABLE IF NOT EXISTS program_facts(fact_id INTEGER PRIMARY KEY, year INTEGER, month INTEGER, title_id INTEGER, channel_id INTEGER, record_count INTEGER, watch_count INTEGER, scheduled_duration INTEGER, record_duration INTEGER, watch_duration INTEGER, barely_watched_count INTEGER);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_year ON program_facts (year);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_month ON program_facts (month);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_title_id ON program_facts (title_id);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_channel_id ON program_facts (channel_id);"

  # Get complete set of records, sorted so activities for a single program are adjacent in type and time order.
  set records [$tvdiarydb query "SELECT programs.program_id, programs.title_id, programs.channel_id, activities.type, activities.start, activities.end, programs.duration FROM programs, activities WHERE programs.program_id = activities.program_id ORDER BY programs.program_id, programs.title_id, programs.channel_id, activities.type, activities.start"]

  # Accumulate the details to be inserted into the facts table. Ajacent activities for the same program of the same type have their durations combined.
  # This ensures a single program recording split in two get counted as one.
  set ::accumulated_record {}
  
  # The scheduled duration for a program is maintained slightly differently, as it's counted once per program instance per day, and not per activity.
  
  foreach record $records {
    # Calculate the duration for this activity.
    puts "record:$record"
    set record(time) [expr ($record(end) - $record(start)) / 60]
    # Get the date for the record.
    set date_parts [get_tv_date $record(start)]
    puts "Converted date=$date_parts"
    set record(year) [lindex $date_parts 0]
    set record(month) [lindex $date_parts 1]
    set record(day) [lindex $date_parts 2]

    if { [llength $::accumulated_record] } {
      if { [is_extension $record] } {
        # There is an accumulated record & this record extends it, so combine.
        combine_accumulated $record
      } else {
        # There is an accumulated record, but this record is different, so save the accumulated record and start accumulating with this record.
        save_accumulated $tvdiarydb
        set ::accumulated_record $record
      }
    } else {
      # There is no accumulated record, so start accumulating with this record.
      set ::accumulated_record $record
    }
  }

  # If there is an unsaved accumulated record, save it at the end.
  if { [llength $::accumulated_record] } {
    save_accumulated $tvdiarydb
    set ::accumulated_record {}
  }

  #$tvdiarydb query "VACUUM;"
}

#
# Check whether the new record is an extension to the accumulated_record.
# That is, it is the same programme and activity type on the same day.
#
proc is_extension { record } {
  if { $::accumulated_record(program_id) == $record(program_id)
    && $::accumulated_record(type) == $record(type)
    && $::accumulated_record(year) == $record(year)
    && $::accumulated_record(month) == $record(month)
    && $::accumulated_record(day) == $record(day) } {
    return 1
  } else {
    return 0
  }
}

#
#
proc combine_accumulated { record } {
  set ::accumulated_record(time) [expr $::accumulated_record(time) + $record(time)]
  puts "extended to $::accumulated_record(time)"
}

#
#
proc save_accumulated { tvdiarydb } {
  #puts "::accumulated_record:$::accumulated_record"
  if { $::accumulated_record(type) eq "R" } {
puts "Accumulating record type R"
    set record_count 1
    set watch_count 0
    set scheduled_duration $::accumulated_record(duration)
    set record_duration $::accumulated_record(time)
    set watch_duration 0
    set barely_watched_count 0
  } else {
puts "Accumulating record type W/L"
    set record_count 0
    set watch_count 1
    set scheduled_duration $::accumulated_record(duration)
    set record_duration 0
    set watch_duration $::accumulated_record(time)
    if { $watch_duration < ($scheduled_duration / 2) } {
puts "Barely watched $watch_duration < $scheduled_duration / 2"
      set barely_watched_count 1
    } else {
puts "NOT Barely watched"
      set barely_watched_count 0
    }
  }
  # Fetch any existing record having the same dimensions - ie same program in same time period - and combine with the accumulated record.
  set _facts [$tvdiarydb query "SELECT fact_id, record_count, watch_count, scheduled_duration, record_duration, watch_duration, barely_watched_count FROM program_facts WHERE year = $::accumulated_record(year) AND month = $::accumulated_record(month) AND title_id = $::accumulated_record(title_id) AND channel_id = $::accumulated_record(channel_id)"]
puts "Length of returned _facts: [llength $_facts]"
  if { [llength $_facts] eq 1 } {
    set facts [lindex $_facts 0]
puts "Returned facts=$facts"
    set record_count [expr $record_count + $facts(record_count)]
    set watch_count [expr $watch_count + $facts(watch_count)]
    set scheduled_duration [expr $scheduled_duration + $facts(scheduled_duration)]
    set record_duration [expr $record_duration + $facts(record_duration)]
    set watch_duration [expr $watch_duration + $facts(watch_duration)]
    set barely_watched_count [expr $barely_watched_count + $facts(barely_watched_count)]
    $tvdiarydb query "
      UPDATE program_facts SET record_count = %s, watch_count = %s, scheduled_duration = %s, record_duration = %s, watch_duration = %s, barely_watched_count = %s WHERE fact_id = %s
      " $record_count $watch_count $scheduled_duration $record_duration $watch_duration $barely_watched_count $facts(fact_id)
  } else {
    $tvdiarydb query "
      INSERT INTO program_facts (year, month, title_id, channel_id, record_count, watch_count, scheduled_duration, record_duration, watch_duration, barely_watched_count)
      VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
      " $::accumulated_record(year) $::accumulated_record(month) $::accumulated_record(title_id) $::accumulated_record(channel_id) $record_count $watch_count $scheduled_duration $record_duration $watch_duration $barely_watched_count
  }
}

#
# Convert the given time to the TV date it belongs to. The input time is a UTC epoch value.
# Since the start of TV day is in the local time, convert from UTC to local first, check which side
# of the TV day start it is. If it's before, adjust the time back and re-calculate the local time.
# Returns a list containing the year, month and day numbers.
#
proc get_tv_date { t } {
  set locparts [split [clock format $t -format "%Y,%m,%d,%H,%M"] ","]
  set day_time [expr ([lindex $locparts 3] * 60 + [lindex $locparts 4]) * 60]
  if { $day_time < $::day_start } {
    set locparts [split [clock format [expr $t - $::day_start] -format "%Y,%m,%d,%H,%M"] ","]
  }
  return [list [lindex $locparts 0] [lindex $locparts 1] [lindex $locparts 2] ]
}

main
