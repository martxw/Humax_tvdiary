#!/mod/bin/jimsh
#
# Aggregate statistics in the tvdiary database.
# Author: Martin Wink, 2014.
#

# In case of error - break glass!
#foreach key [lsort [dict keys $env]] {puts "env($key)=$env($key)"}
#puts "auto_path=$auto_path"

#source /mod/webif/lib/setup
source /mod/webif/html/tvdiary/tvdiary_db.jim
if { ![exists -proc sqlite3.open] } { package require sqlite3 }

# --------------------------------------------------------------
# Declare globals
# --------------------------------------------------------------
set logging 1

set DB_FILEPATH "/mod/etc/tvdiary.db"

set current_time [clock seconds]
set log_date_fmt "%d/%m/%Y-%H:%M:%S"
set logging_time [clock format $current_time -format $log_date_fmt]
if { $::logging } {
  puts "\n$logging_time: tvdiary_aggregate.jim"
}

# --------------------------------------------------------------
# Declare procedures
# --------------------------------------------------------------

#
# Create or open the database file.
#
proc openDB {} {
  set tvdiarydb [sqlite3.open $::DB_FILEPATH]

  return $tvdiarydb;
}

#
# Main
#
proc main {} {
  try {
    #
    # Get a lock for the database.
    #
    if {![acquire_lock tvdiary_db]} {
      throw "Cannot acquire exclusive lock for tvdiary.tb."
    }

    set tvdiarydb [openDB]

    set settings_val [get_setting $tvdiarydb "day_start"]
    if { $settings_val eq "" } {
      set ::day_start 0
    } else {
      set parts [split $settings_val ":"]
      set ::day_start [expr ([lindex $parts 0] * 60 + [lindex $parts 1]) * 60]
    }
    puts "day_start set to $::day_start"

    aggregate $tvdiarydb

    $tvdiarydb close

    #
    # Closed the DB so release the lock.
    #
    release_lock tvdiary_db

    puts "$::logging_time: Aggregation completed successfully."
  } on error { msg } {
    puts "$::logging_time: Aggregation failed. \[$msg\]"
    puts [info stacktrace]
    exit
  }
}

#
# Calculate the aggregated summary statistics.
#
proc aggregate { tvdiarydb } {

  # TODO: Move table creation to migration code. Only here for development.
  # Program fact table. The year and month are dimensions, as are the title and channel IDs.
  $tvdiarydb query "DROP TABLE IF EXISTS program_facts;"
  $tvdiarydb query "CREATE TABLE IF NOT EXISTS program_facts(fact_id INTEGER PRIMARY KEY, year INTEGER, month INTEGER, title_id INTEGER, channel_id INTEGER, recorded_count INTEGER, played_count INTEGER, live_count INTEGER, scheduled_duration INTEGER, recorded_duration INTEGER, played_duration INTEGER, live_duration INTEGER, barely_watched_count INTEGER);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_year ON program_facts (year);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_month ON program_facts (month);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_title_id ON program_facts (title_id);"
  $tvdiarydb query "CREATE INDEX IF NOT EXISTS ipf_channel_id ON program_facts (channel_id);"

  # Get complete set of records, sorted so activities for a single program are adjacent in type and time order.
  set records [$tvdiarydb query "
    SELECT programs.program_id, programs.title_id, programs.channel_id, activities.type, activities.start, activities.end, programs.duration AS scheduled_duration
    FROM programs, activities
    WHERE programs.program_id = activities.program_id
    ORDER BY programs.program_id, activities.start
  "]

  # Accumulate the details to be inserted into the facts table. Ajacent activities for the same program on the same day have their durations combined.
  # This ensures a single program recording split in two get counted as one. The type field in the accumlated record is useless.
  # The scheduled duration is counted only once per day.
  set ::accumulated_record {}

  foreach record $records {
    puts "record:$record"

    # Calculate the durations & count for this activity.
    if { $record(type) eq "R" } {
      set record(recorded_duration) [expr ($record(end) - $record(start)) / 60]
      set record(played_duration) 0
      set record(live_duration) 0
      set record(recorded_count) 1
      set record(played_count) 0
      set record(live_count) 0
    } elseif { $record(type) eq "P" } {
      set record(recorded_duration) 0
      set record(played_duration) [expr ($record(end) - $record(start)) / 60]
      set record(live_duration) 0
      set record(recorded_count) 0
      set record(played_count) 1
      set record(live_count) 0
    } else {
      set record(recorded_duration) 0
      set record(played_duration) 0
      set record(live_duration) [expr ($record(end) - $record(start)) / 60]
      set record(recorded_count) 0
      set record(played_count) 0
      set record(live_count) 1
    }

    # Get the date for the record.
    set date_parts [get_tv_date $record(start)]
    puts "Converted date=$date_parts"
    set record(year) [lindex $date_parts 0]
    set record(month) [lindex $date_parts 1]
    set record(day) [lindex $date_parts 2]

    if { [llength $::accumulated_record] } {
      if { [is_extension $record] } {
        # There is an accumulated record & this record extends it, so combine.
        combine_accumulated $record
      } else {
        # There is an accumulated record, but this record is for a different program or day, so save the accumulated record and restart accumulating with this record.
        save_accumulated $tvdiarydb
        set ::accumulated_record $record
      }
    } else {
      # There is no accumulated record, so start accumulating with this record.
      set ::accumulated_record $record
    }
  }

  # If there is an unsaved accumulated record, save it at the end.
  if { [llength $::accumulated_record] } {
    save_accumulated $tvdiarydb
    set ::accumulated_record {}
  }

  #$tvdiarydb query "VACUUM;"
}

#
# Check whether the new record is an extension to the accumulated_record.
# That is, it is the same programme within the same month.
#
proc is_extension { record } {
  if { $::accumulated_record(program_id) == $record(program_id)
    && $::accumulated_record(year) == $record(year)
    && $::accumulated_record(month) == $record(month) } {
    return 1
  } else {
    return 0
  }
}

#
# Combine the details of a single record with the already accumulated record.
# Counts ORed together and durations added.
#
proc combine_accumulated { record } {
  set ::accumulated_record(recorded_duration) [expr $::accumulated_record(recorded_duration) + $record(recorded_duration)]
  set ::accumulated_record(played_duration) [expr $::accumulated_record(played_duration) + $record(played_duration)]
  set ::accumulated_record(live_duration) [expr $::accumulated_record(live_duration) + $record(live_duration)]
  set ::accumulated_record(recorded_count) [expr $::accumulated_record(recorded_count) || $record(recorded_count)]
  set ::accumulated_record(played_count) [expr $::accumulated_record(played_count) || $record(played_count)]
  set ::accumulated_record(live_count) [expr $::accumulated_record(live_count) || $record(live_count)]
}

#
# Add the accumulated record to the database.
#
proc save_accumulated { tvdiarydb } {
  puts "::accumulated_record:$::accumulated_record"
  if { $::accumulated_record(played_duration) + $::accumulated_record(live_duration) < ($::accumulated_record(scheduled_duration) / 2) } {
puts "Barely watched $::accumulated_record(played_duration) + $::accumulated_record(live_duration) < $::accumulated_record(scheduled_duration) / 2"
    set barely_watched_count 1
  } else {
puts "NOT barely watched"
    set barely_watched_count 0
  }

  # Fetch any existing record having the same dimensions - ie same program in same time period - and combine with the accumulated record.
  set _facts [$tvdiarydb query "SELECT fact_id, recorded_count, played_count, live_count, scheduled_duration, recorded_duration, played_duration, live_duration, barely_watched_count FROM program_facts WHERE year = $::accumulated_record(year) AND month = $::accumulated_record(month) AND title_id = $::accumulated_record(title_id) AND channel_id = $::accumulated_record(channel_id)"]
puts "Length of returned _facts: [llength $_facts]"
  if { [llength $_facts] eq 1 } {
    set facts [lindex $_facts 0]
puts "Returned facts=$facts"
    set recorded_count [expr $::accumulated_record(recorded_count) + $facts(recorded_count)]
    set played_count [expr $::accumulated_record(played_count) + $facts(played_count)]
    set live_count [expr $::accumulated_record(live_count) + $facts(live_count)]
    set scheduled_duration [expr $::accumulated_record(scheduled_duration) + $facts(scheduled_duration)]
    set recorded_duration [expr $::accumulated_record(recorded_duration) + $facts(recorded_duration)]
    set played_duration [expr $::accumulated_record(played_duration) + $facts(played_duration)]
    set live_duration [expr $::accumulated_record(live_duration) + $facts(live_duration)]
    set barely_watched_count [expr $barely_watched_count + $facts(barely_watched_count)]
    $tvdiarydb query "
      UPDATE program_facts SET recorded_count = %s, played_count = %s, live_count = %s, scheduled_duration = %s, recorded_duration = %s, played_duration = %s, live_duration = %s, barely_watched_count = %s WHERE fact_id = %s
      " $recorded_count $played_count $live_count $scheduled_duration $recorded_duration $played_duration $live_duration $barely_watched_count $facts(fact_id)
  } else {
    $tvdiarydb query "
      INSERT INTO program_facts (year, month, title_id, channel_id, recorded_count, played_count, live_count, scheduled_duration, recorded_duration, played_duration, live_duration, barely_watched_count)
      VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
      " $::accumulated_record(year) $::accumulated_record(month) $::accumulated_record(title_id) $::accumulated_record(channel_id) $::accumulated_record(recorded_count) $::accumulated_record(played_count) $::accumulated_record(live_count) $::accumulated_record(scheduled_duration) $::accumulated_record(recorded_duration) $::accumulated_record(played_duration) $::accumulated_record(live_duration) $barely_watched_count
  }
}

#
# Convert the given time to the TV date it belongs to. The input time is a UTC epoch value.
# Since the start of TV day is in the local time, convert from UTC to local first, check which side
# of the TV day start it is. If it's before, adjust the time back and re-calculate the local time.
# Returns a list containing the year, month and day numbers.
#
proc get_tv_date { t } {
  set locparts [split [clock format $t -format "%Y,%m,%d,%H,%M"] ","]
  set day_time [expr ([lindex $locparts 3] * 60 + [lindex $locparts 4]) * 60]
  if { $day_time < $::day_start } {
    set locparts [split [clock format [expr $t - $::day_start] -format "%Y,%m,%d,%H,%M"] ","]
  }
  return [list [lindex $locparts 0] [lindex $locparts 1] [lindex $locparts 2] ]
}

main
