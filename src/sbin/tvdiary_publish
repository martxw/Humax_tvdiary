#!/mod/bin/jimsh
#
# Work in progress!
# Publish the TV Diary contents to a separate web server.
#
# Author: Martin Wink, 2013.
#

package require sqlite3

# --------------------------------------------------------------
# Declare globals
# --------------------------------------------------------------

set date_fmt "%Y_%m_%d"
set seconds_per_day 86400
set days_forward 7

# The script to render the updates.
set DAY_VIEW_PATH "/mod/webif/html/tvdiary/day_view.jim"

# The TV channel icons on the Humax.
set CHANNEL_ICONS_PATH "/mod/webif/html/img/channels/out"

set DB_FILEPATH "/mod/etc/tvdiary.db"
set CONF_FILEPATH "/mod/etc/tvdiary.conf"

# I'm storing the icons relative to the HTML.
set CHANNEL_ICONS_URL "channels"

# --------------------------------------------------------------
# Command line parameters
# --------------------------------------------------------------

if { $argc != 4 } {
  puts "Usage: $argv0 <ftp_host> <ftp_user> <ftp_password> <ftp_directory>"
  exit -1
}
set ftp_host [lindex $argv 0]
set ftp_user [lindex $argv 1]
set ftp_pw [lindex $argv 2]
set ftp_dir [lindex $argv 3]

# --------------------------------------------------------------
# Declare procedures
# --------------------------------------------------------------

proc round_to_day_start { t day_start } {
  return [expr int(($t - $day_start) / $::seconds_per_day) * $::seconds_per_day + $day_start]
}

proc main {} {
  # One temp file for everything.
  set tmpfile [file tempfile]

  # Get the configured start time of the TV day for writing to calendar_params.js.
  # Converted to seconds. Default here to 00:00 (0 * 60 + 0).
  set day_start [expr (0 * 60 + 0) * 60]
  try {
    set settings_fd [open $::CONF_FILEPATH r]
    foreach line [split [read $settings_fd] "\n"] {
      lassign $line settings_key settings_val
      switch $settings_key {
        "day_start" {
          set parts [split $settings_val ":"]
          set day_start [expr ([lindex $parts 0] * 60 + [lindex $parts 1]) * 60]
          break
        }
      }
    }
    $settings_fd close
  } on error { msg } {
    # Use the default if no file.
  }
  puts "day_start=$day_start"

  # Key values to calculate:
  # update_from_time - the first day's data to upload this time.
  #   1 day before the last UPDATE date from the server..
  #   If nothing IS already uploaded, the upload ALL the data we have, from the minimum date in the DB.
  #   If there is also nothing in the DB, then upload from today, as the planned recordings are included.
  # update_to_time - the last day's data to upload this time.
  #   7 days from now, to include planned recordings. These will be overwritten as we remember today's UPDATE date.

  # When we update the server's calendar_params.js:
  # min_time - the earliest day's data available on the server.
  #   If a value was read from the server, that value will remain unless the update_from_time is earlier.
  # max_time - the latest day's data available in the server.
  #   This is ALWAYS the update_to_time, assuming time always goes forwards!
  # update_time - the reference date of today's update, so later on updates are from just before this.
  #   Ensures that if no updates are performed for a few days, the gap gets filled in.

  # Calculate the program default from and to times to generate updates for.
  set current_time [clock seconds]
  # Counter-intuitively - *subtract* the day_start before rounding down to the start of the day, so that at 1am
  # we get yesterday's TV listings, but then add day_start back on so we get listings from the right start time.
  set today_start [round_to_day_start $current_time $day_start]

  # Find out how much data there is in the database to find the absolute min time for the update,
  # rounded to the start of the day. Default to today so planned recordings are included at the very least.
  set db_min_start $today_start
  if { [file exists $::DB_FILEPATH] } {
    set tvdiarydb [sqlite3.open $::DB_FILEPATH]

    set _minstart [$tvdiarydb query "SELECT MIN(start) FROM activities"]
    if { [llength $_minstart] == 1 } {
      set db_min_start [expr int([lindex [lindex $_minstart 0] 1] / $::seconds_per_day) * $::seconds_per_day]
    }

    $tvdiarydb close
  }

  # If nothing is found on the server, the min date shown on the calendar and the effective last update is the earliest date we have from the database.
  set srv_min_time $db_min_start
  set srv_update_time $db_min_start

  # Get the dates from the server.
  try {
    set cmd "exec ftpget -u $::ftp_user -p $::ftp_pw $::ftp_host $tmpfile $::ftp_dir/calendar_params.js"
    puts $cmd
    eval $cmd

    set params_fd [open $tmpfile r]
    foreach line [split [read $params_fd] "\n"] {
      lassign [split $line "="] line_key line_val
      lassign [split $line_val ";"] line_val x
      switch $line_key {
        "var min_time" {
          # If the server already has a date we'll re-use it, unless we send data from earlier.
          set srv_min_time $line_val
        }
        "var max_time" {
          # Get it, but the max time will always be several days after this update.
          set srv_max_time $line_val
        }
        "var update_time" {
          # Get it, but the update time will be saved as today.
          set srv_update_time $line_val
        }
        default {
        }
      }
    }
    $params_fd close
  } on error { msg } {
    puts "Error getting calendar_params.js: $msg"
    # Continue using defaulted srv_min_time.
  }

  # 1 day back from the last update, then round to start of the TV day.
  set update_from_time [expr $srv_update_time - $::seconds_per_day]
  if { $update_from_time < $db_min_start } {
    set update_from_time $db_min_start
  }
  set update_from_time [round_to_day_start $update_from_time $day_start]

  # 7 days from today.
  set update_to_time [expr $today_start + ($::days_forward * $::seconds_per_day)]

  # Normally the server's min time will remain, but if the update is earlier, overwrite it.
  if { ($update_from_time < $srv_min_time) && ($update_from_time > $db_min_start)} {
    set srv_min_time $update_from_time
  }

  puts "today_start=[clock format $today_start]"
  puts "update_from_time=[clock format $update_from_time]"
  puts "update_to_time=[clock format $update_to_time]"
  puts "srv_min_time=[clock format $srv_min_time]"
  
  for { set t $update_from_time } { $t <= $update_to_time } { incr t $::seconds_per_day } {
    foreach type {R W} {
      set target_file "[clock format $t -format $::date_fmt]_$type.html"
      set cmd "exec $::DAY_VIEW_PATH $t $type $::CHANNEL_ICONS_PATH $::CHANNEL_ICONS_URL > $tmpfile"
      puts "[clock format $t] $cmd"
      eval $cmd
      set cmd "exec ftpput -u $::ftp_user -p $::ftp_pw $::ftp_host $::ftp_dir/$target_file $tmpfile"
      puts "$cmd"
      eval $cmd
    }
  }
  
  # Rewrite the calendar_params.js and upload it.
  set params_fd [open $tmpfile w]
  puts $params_fd "var min_time=$srv_min_time; // [clock format $srv_min_time]"
  puts $params_fd "var max_time=$update_to_time; // [clock format $update_to_time]"
  puts $params_fd "var shapshot_time=$today_start; // [clock format $today_start]"
  puts $params_fd "var day_start=$day_start; // "

  $params_fd close
  set cmd "exec ftpput -u $::ftp_user -p $::ftp_pw $::ftp_host $::ftp_dir/calendar_params.js $tmpfile"
  puts $cmd
  eval $cmd

  file delete $tmpfile
}

proc send_images {} {
  set icon_files [glob $::CHANNEL_ICONS_PATH/*.png]
  puts "#icon_files=[llength $icon_files]"
  foreach filename [lsort $icon_files] {
    if { !([file isfile $filename] && [file readable $filename]) } {
      puts "Cant read $filename"
    } else {
      set cmd "exec ftpput -u $::ftp_user -p $::ftp_pw $::ftp_host \"$::ftp_dir/$::CHANNEL_ICONS_URL/[file tail $filename]\" \"$filename\""
      puts $cmd
      eval $cmd
    }
  }

  set additional {
    "/opt/share/images/blue/516_1_26_Freeview_Logo.png"
    "/opt/share/images/blue/154_1_00_WIN_MD116_1L.png"
    "/opt/share/images/blue/154_1_00_WIN_MD116_3R.png"
    "/opt/share/images/blue/154_1_00_WIN_MD116_2C.png"
  }
  foreach filename [lsort $additional] {
    if { !([file isfile $filename] && [file readable $filename]) } {
      puts "Cant read $filename"
    } else {
      set cmd "exec ftpput -u $::ftp_user -p $::ftp_pw $::ftp_host \"$::ftp_dir/images/[file tail $filename]\" \"$filename\""
      puts $cmd
      eval $cmd
    }
  }
}

main
#send_images
